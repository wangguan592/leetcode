1、深度优先遍历

二叉树的深度优先遍历和先序遍历结果一样的。 思想是采用栈， 首先将根结点压入栈，如果栈不为空，而后出栈并输出当前结点中值，而后先把右子树压入栈，再把左子树压入栈，再判断栈是否为空，循环.....
步骤如下:
(1) 树的根结点入栈
(2)判断栈是否为空，不为空，则出栈，并输出出栈树结点的值
(3)出栈树结点的右子树入栈
(4)出栈树结点的左子树入栈
(5)循环回到(2)

2、广度优先遍历

按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。算法：

(1)初始化一个队列，并把根结点入列队；
(2)当队列为非空时，循环执行步骤3到步骤5，否则执行6；
(3)出队列取得一个结点，访问该结点；
(4)若该结点的左子树为非空，则将该结点的左子树入队列；
(5)若该结点的右子树为非空，则将该结点的右子树入队列；



3、前序遍历
 根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：

 对于任一结点P：

 1)访问结点P，并将结点P入栈;

 2)判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1);若不为空，则将P的左孩子置为当前的结点P;

 3)直到P为NULL并且栈为空，则遍历结束。

4、中序遍历
 根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下：

   对于任一结点P，

 1)若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；

 2)若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；

 3)直到P为NULL并且栈为空则遍历结束s

5、后序遍历
后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。下面介绍两种思路。

第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，
但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，
该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，
只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。

第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，
则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，
则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。